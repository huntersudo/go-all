package main

// 为什么字符串不允许修改
//像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，
//只 有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。
//
//因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可 修改的约定。

//[]byte转换成string一定会拷贝内存吗？
// 有时候只是临时需要字符串的场景下，byte切片转换成 string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存。
//编译器会识别如下临时场景：
// 使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）；
// 字符串拼接，如”<” + “string(b)” + “>”；
// 字符串比较：string(b) == “foo”

//string和[]byte如何取舍

/*string 擅长的场景：
  需要字符串比较的场景；
  不需要nil字符串的场景；

[]byte擅长的场景：
  修改字符串的场景，尤其是修改粒度为1个字节；
  函数返回值，需要用nil表示含义的场景；
  需要切片操作的场景；

虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中 []byte使用更多。
*/

