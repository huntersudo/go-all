# 书籍勘误表
## 前言添加版本号
本书由21章组成 ->  本书基于Go1.14版本编写，由21章组成...
## 第1章
* (1.1) 第1页第3段第1行： 通过了解Go语言编辑器 -> 通过了解Go语言编译器
* (1.3) 第3页第3行: ":= " -> ":="
* (1.4) 第5页图1-4： ConstDeal -> ConstDecl 
* (1.6) 第4行 TINT() -> TINT
## 第2章
* (2.2) 28页第5行: ^应该上标
* (2.3) 第2行：^应该上标
* (2.3.2) 灰色第一个代码： \\\n\\\n -> \n
* (2.10) 40页正文第二行：56.78可以表示为5678×10^2 ->56.78可以表示为5678×10^  (注意^应上标)

## 第5章
* (第3次印刷修正)(5.5) 第3段第一行 字符常量 -> 字符串常量
* (第3次印刷修正)(5.5) 第3段第2行 字符常量 -> 字符串常量

## 第7章
* (7.1.1) 第74页第2段： date ->data

## 第8章 哈希表与Go语言实现机制
* 86页最后一行:  
Go语言中的哈希表采用的是开放寻址法中的线性探测（Linear Probing）策略，线性探测策略是顺序（每次探测间隔为1）的。由于良好的CPU高速缓存利用率和高性能，该算法是现代计算机体系中使用最广泛的结构。在第12章还会看到，接口使用的全局itab哈希表采用了开放寻址法中的二次方探测策略。

修改为：

Go语言中的哈希表采用的是优化的拉链法，每一个桶中存储了8个元素用于加速访问。在第12章还会看到，接口使用的全局itab哈希表采用了开放寻址法中的二次方探测策略。

* 104页总结： 
Go语言为了解决哈希冲突使用了开放式寻址中的线性地址探测策略 -> Go语言为了解决哈希冲突使用了优化后的拉链法

* 90页^改为上标

## 第9章 
* (9.3) 107页 函数栈第一段
每个线程都有一个被称为栈的内存区域，其遵循一种先入先出（FIFO）的形式 -> 每个线程都有一个被称为栈的内存区域，其遵循一种后进先出（LIFO, Last In First Out）的形式
* (9.3) 倒数第5行 因为数据是以先进先出的方式 -> 因为数据是以后进先出的方式
* (第3次印刷修正)(9.5) 图9-4下一行： 当main函数返回时 -> 当mul函数返回时
## 第12章
* (12.4.4) 161页灰色第三个代码:  三角形周长（代码第一个出现的位置） -> 长方形周长
* (12.4.5) 正文第3行: Writer实现了一系列方法 -> os.File实现了一系列方法
* (12.5.2) 正文第2段: data字段存储了接口中动态类型的函数指针 -> data字段存储了接口中动态类型的数据指针

## 第14章
* 217页第2行 GO语言 -> Go语言
* (14.5) 代码第一段: 代码第一行for _, link := range links { checkLink(link) }重复了，直接删除 

## 第15章
* (15.5.1) 第2行 括号的格式不对
* (15.5.2) 236页正文第2行: 那么调度器会将本地运行队列的一半放入局部运行队列 -> 那么调度器会将本地运行队列的一半放入全局运行队列

## 第16章
* (第3次印刷修正)(16.5.1) 第5行 如果scase的类型为caseRecv,则和普通的通道发送一样 -> 如果scase的类型为caseSend,则和普通的通道发送一样
* (第3次印刷修正)(16.6)总结 第1行  Go语言采用了CPS并发 -> Go语言采用了CSP并发
* (第3次印刷修正)(16.6)总结 第3行  fin-in、fin-out -> fan-in、fan-out

## 第17章
* 107页第二行: trace工具 -> race工具
* (17.5)  第2段： trace工具 -> race工具

## 第18章
* (第4次印刷修正)(18.2.2) 由于allocCache元素为uint64，因此其最多一次缓存64字节。-> 由于allocCache元素为uint64，因此其最多一次缓存64个元素。
* (第4次印刷修正)(18.2.2) 当bit位为1代表当前对应的span中的元素已经分配。 ->  当bit位为0代表当前对应的span中的元素已经分配，这里的设计是为了sys.Ctz64函数加速计算。因此sys.Ctz64可以直接计算 allocCache 最后面有几个 0 (也就是在第几个 bit 遇到第一个 1) 来使用
* (第4次印刷修正)(图18-7下一段)
因此，只要从allocCache开始找到哪一位为0即可。假如X位为0，那么X + freeindex 为当前span中可用的元素序号。当allocCache中bit位全部被标记为1后，需要移动freeindex，并更新allocCache，一直到span中元素末尾为止。
->
因此，只要从allocCache开始找到哪一位为1即可。假如X位为1，那么X + freeindex 为当前span中可用的元素序号。当allocCache中bit位全部被标记为0后，需要移动freeindex，并更新allocCache，一直到span中元素末尾为止。

## 第20章
图20-23  p.k=&k -> p.x=&k

图20-25  p.k=&k -> p.x=&k

## 代码缩进问题

