### 查询条件方法

查询和统计主要使用`Get`, `Find`, `Count`, `Rows`, `Iterate`这几个方法，同时大部分函数在调用`Update`, `Delete`时也是可用的。在进行查询时可以使用多个方法来形成查询条件，条件函数如下：

* Alias(string)

给Table设定一个别名

```Go
engine.Alias("o").Where("o.name = ?", name).Get(&order)
```

* And(string, …interface{})

和Where函数中的条件基本相同，作为条件

```Go
engine.Where(...).And(...).Get(&order)
```

* Asc(…string)

指定字段名正序排序，可以组合

```Go
engine.Asc("id").Find(&orders)
```

* Desc(…string)

指定字段名逆序排序，可以组合

```Go
engine.Asc("id").Desc("time").Find(&orders)
```

* ID(interface{})

传入一个主键字段的值，作为查询条件，如

```Go
var user User
engine.ID(1).Get(&user)
// SELECT * FROM user Where id = 1
```

如果是复合主键，则可以

```Go
engine.ID(core.PK{1, "name"}).Get(&user)
// SELECT * FROM user Where id =1 AND name= 'name'
```

传入的两个参数按照struct中pk标记字段出现的顺序赋值。

* Or(interface{}, …interface{})

和Where函数中的条件基本相同，作为条件

* OrderBy(string)

按照指定的顺序进行排序

* Select(string)

指定select语句的字段部分内容，例如：

```Go
engine.Select("a.*, (select name from b limit 1) as name").Find(&beans)

engine.Select("a.*, (select name from b limit 1) as name").Get(&bean)
```

* SQL(string, …interface{})

执行指定的Sql语句，并把结果映射到结构体。有时，当选择内容或者条件比较复杂时，可以直接使用Sql，例如：

```Go
engine.SQL("select * from table").Find(&beans)
```

* Where(string, …interface{})

和SQL中Where语句中的条件基本相同，作为条件

```Go
engine.Where("a = ? AND b = ?", 1, 2).Find(&beans)

engine.Where(builder.Eq{"a":1, "b": 2}).Find(&beans)

engine.Where(builder.Eq{"a":1}.Or(builder.Eq{"b": 2})).Find(&beans)
```

* In(string, …interface{})

某字段在一些值中，这里需要注意必须是[]interface{}才可以展开，由于Go语言的限制，[]int64等不可以直接展开，而是通过传递一个slice。第二个参数也可以是一个*builder.Builder 指针。示例代码如下：

```Go
// select from table where column in (1,2,3)
engine.In("cloumn", 1, 2, 3).Find()

// select from table where column in (1,2,3)
engine.In("column", []int{1, 2, 3}).Find()

// select from table where column in (select column from table2 where a = 1)
engine.In("column", builder.Select("column").From("table2").Where(builder.Eq{"a":1})).Find()
```

* Cols(…string)

只查询或更新某些指定的字段，默认是查询所有映射的字段或者根据Update的第一个参数来判断更新的字段。例如：

```Go
engine.Cols("age", "name").Get(&usr)
// SELECT age, name FROM user limit 1
engine.Cols("age", "name").Find(&users)
// SELECT age, name FROM user
engine.Cols("age", "name").Update(&user)
// UPDATE user SET age=? AND name=?
```

* AllCols()

查询或更新所有字段，一般与Update配合使用，因为默认Update只更新非0，非""，非bool的字段。

```Go
engine.AllCols().Id(1).Update(&user)
// UPDATE user SET name = ?, age =?, gender =? WHERE id = 1
```

* MustCols(…string)

某些字段必须更新，一般与Update配合使用。

* Omit(...string)

和cols相反，此函数指定排除某些指定的字段。注意：此方法和Cols方法不可同时使用。

```Go
// 例1：
engine.Omit("age", "gender").Update(&user)
// UPDATE user SET name = ? AND department = ?
// 例2：
engine.Omit("age, gender").Insert(&user)
// INSERT INTO user (name) values (?) // 这样的话age和gender会给默认值
// 例3：
engine.Omit("age", "gender").Find(&users)
// SELECT name FROM user //只select除age和gender字段的其它字段
```

* Distinct(…string)

按照参数中指定的字段归类结果。

```Go
engine.Distinct("age", "department").Find(&users)
// SELECT DISTINCT age, department FROM user
```

注意：当开启了缓存时，此方法的调用将在当前查询中禁用缓存。因为缓存系统当前依赖Id，而此时无法获得Id

* Table(nameOrStructPtr interface{})

传入表名称或者结构体指针，如果传入的是结构体指针，则按照IMapper的规则提取出表名

* Limit(int, …int)

限制获取的数目，第一个参数为条数，第二个参数表示开始位置，如果不传则为0

* Top(int)

相当于Limit(int, 0)

* Join(string,interface{},string)

第一个参数为连接类型，当前支持INNER, LEFT OUTER, CROSS中的一个值，
第二个参数为string类型的表名，表对应的结构体指针或者为两个值的[]string，表示表名和别名，
第三个参数为连接条件

    详细用法参见 [5.Join的使用](5.join.md)

* GroupBy(string)

Groupby的参数字符串

* Having(string)

Having的参数字符串
